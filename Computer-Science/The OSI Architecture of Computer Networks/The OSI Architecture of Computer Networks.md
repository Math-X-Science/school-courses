<!--
pandoc -s -o output.html input.md --mathjax
-->

# 计算机网络复习



费曼学习法有云： 把一个领域里艰深的公式定理或者道理讲得让小孩子也能理解听懂，那么才算是真正地理解。<br>

而我这里的方法是：一知半解，用自己的话讲出来，后面反复修正，逐渐补全。<br>

## 1.概述

### 列车问题： 发送-传播-转发-接收

$$总时延=发送时延+传播时延+转发时延迟$$

$$理想发送时延=\frac{数据块长度}{带宽}$$

$$传播时延=\frac{传输信道长度}{数据传输速率}$$

理想状态不考虑转发时延迟。

### OSI体系结构

物数网运会表应。

- 物理层
- 数据链路层
- 网络层
- 运输层
- 会话层
- 表示层
- 应用层

这些其实就是之后章节的主题了。

## 2.物理层

### 数据的存储，转换和传输

数据的存储，是bit的形式，是数字信号。

但是它并不适合直接传输，而需要进行调制，调成模拟信号，然后再进行传输，最后再转换回数字信号。应该是为了减少信道干扰。

而似乎充当调制和解调的是光猫？猫？喵？在大概十年前我还能见到它，现在似乎见不到了。

勘误：似乎是 **光纤终端** 进行的调制和解调

### 信息，数据，信号

信息是物理世界的概念，数据是计算机中的二进制流存储形式，信号是数据传输时的体现。

数据一般是离散的，而信号一般是连续的。但不管数据还是信号，实际上都是对信息的采样和模拟。



### 信道

传输信号的通道叫做信道，是我们上述列车问题中的轨道。

#### **理想状态信道的极限传输速率：**

$$C = 2W \log_2 V$$

单位是bps.

C是我们要求的，极限速率。

W是信道带宽，我们发送者一样，信道也有自己的带宽。

V是码元的种类。

不过这个公式让我疑惑，为什么最大传输速率可以超过带宽，这个带宽和我们的发送者的带宽有什么不同，以及，为什么码元种类越多传输速率越快，不应该复杂度变高传输速率变低吗。

**W** 是频率，是Hz,可以这么理解，W 是功率，而频率越高，功率越高。

---

#### 原因：

这里的带宽并不是指的是发送者那里的发送频率有多高（每秒发送多少次）。

而是指这个信道容纳的频率带有多宽，带宽越宽，容纳的频率范围越大。

而这个极限传输速率，实际上求得是类似容积，单位体积信道下的容积作为速率，这个不是列车问题，而是电流问题了。码元和电子差不多。



#### 实际上（高斯白噪声下）信道极限传输速率（香农提的）

$$C = W \log_2(1 + \frac{S}{N})$$

$$\text{SNR (dB)} = 10 \log_{10}\left(\frac{S}{N}\right)$$

新增参数:

S: 信号的功率，一般来说，频率越高，功率越高

N:高斯噪声信号的功率

SNR:信(号)噪(声)比

计算中主要用这个。

**SNR** 才是我们的信噪比，告诉信噪比后还需要计算 $$\frac{S}{N}$$。

区别于无噪声，这里是没有 **2W** 的。而是直接**W**。

### 归零码（RZ），不归零码（NRZ），曼彻斯特码，差分曼彻斯特码

![image-20241201210255982](https://fastly.jsdelivr.net/gh/MrXnneHang/blog_img/BlogHosting/img/24/11/202412012103850.png)

- 不归零码： 我觉得这种编码就很适合我这种傻子，不需要脑子的。
- 归零码： 一个bit分两半，后半总归零（名字由来），前半在上是0,前半在下是1。
- 曼彻斯特码：总是看bit中间，上升是1,下降是0
- 差分曼彻斯特： 总是看bit左边沿，但是这样上图的第一个bit是怎么看出来的。

这些码估计都是用来适用于某种特定情况的，但是对于我来说，第一个就很不错。



### 采样，量化，编码

采样和量化在计算机视觉课上也有接触过。

- 采样是指用数字信号去模拟出模拟信号。并且有一个奇怪的定理是采样频率至少得是信号频率的两倍才能还原。

- 量化是指对一些数字信号进行Normalization。比如0.9,1.8,8.7可能被量化为1,2,9。看规则，一般是根据精度截断，这里似乎又会扯到失真，但是我以前接触的那个和这个可能不是一个概念，后面碰到再说。
- 编码就是根据一定规则编成二进制。



### 100BaseT

- 基带传输(Base): 传输原始信号

- 频带传输: 传输高频信号

100应该是带宽，T是双绞线传输介质。

时间仓促，这样就够。

## 3.数据链路层

### IEEE 802.3的帧格式最小帧长度

![image-20241202164901191](https://fastly.jsdelivr.net/gh/MrXnneHang/blog_img/BlogHosting/img/24/11/202412021649797.png)

每次封装MAC帧一般只管那64字节。其余的似乎并不在考虑。

#### 为什么要封装MAC帧：

- 防止弄混接收人和发送人
- 用于校验，防止数据错乱或者丢失
- 用于标准化

#### 为什么最小帧长度是64字节：

和`CSMA/CD`有关。【**Carrier Sense Multiple Access with Collision Detection**/**载波监听多路访问/碰撞检**】

这里要扯到全双工，半双工。

全双工：高速公路，有双向车道，有隔离带分割。相互间互不干扰。

物理实现： 对于任何一方来说都有两对双绞线或者两条光纤，一对发，一对收，但是在双绞线或者光纤内的信息流向是固定的。因为数据流向固定，所以不存在碰撞风险，不需要`CSMA/CD`进行碰撞检测。

半双工：只有单向车道，固定首发，收的人不能发，发的人不能收，设有碰撞检测。

物理实现：共享信道，同一时间只能有一个方向的数据流动，`CSMA/CD`规则用于检测碰撞。



**帧长度最小规定：**

为了碰撞检测，检测到后会终止发送并且尝试接受或者重新发送。

理由，又得扯到之前的发送时延，在数据发送完毕之前，发生碰撞是可以被检测到的。当发送出去后（发送时延），就不会再管先前发送的信息了。

$$\text{发送时延} \geq 2 \times \text{传播时延}$$

至于为什么是`X2`，这里似乎和各种情况的考量有关。这里时间不够就先跳过了。

